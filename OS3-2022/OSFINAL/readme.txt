3η εργασία Λειτουργικά - Άρης Τσιλιφώνης 1115201700170 - 21/9/22

Υλοποιήθηκε ουρά σημαφόρων με διεργασίες που έχουν προτεραιότητα (από 1-8 τιμές priority). Αρχικά , χρησιμοποιώ τις παραμέτρους του 
argument line ώστε να φτιάξω τους χρόνους μεταξύ διαδοχικών αφίξεων , τους χρόνους ζωής διεργασιών αλλά και τους χρόνους του critical 
section.Η προσομοίωση λειτουργεί με διακριτούς χρόνους. Κόβω το δεκαδικό μέρος από τους εκθετικούς χρόνους .Έχω ένα while loop όπου
αυξάνει τον μετρητή του χρόνου μετά το πέρας μιας χρονοθυρίδας. Στην συνέχεια έχω ένα priority queue όπου βάζω τις ready διεργασίες
(δηλαδή αυτές που είναι έτοιμες να μπούνε σε ουρά σημαφόρου).Γενικά στο πρόγραμμα έχω 4 καταστάσεις διεργασίων (block τιμή στην κλάση
process). Η τιμή 0 για τις ready.Η τιμή 1 για τις διεργασίες που εκτελούν σε critical section.Η τιμή 2 για τις διεργασίες που είναι
μπλοκαρισμένες σε ουρά σημαφόρου.Η τιμή 3 για τις διεργασίες που τελείωσε ο χρόνος ζωής τους.Στην ουρά προτεραιότητας βάζω διεργασίες
ανάλογα με το priority τους.Ωστόσο η ουρά παίρνει ένα struct (priority , timer , pid).Το προτίμησα από το να έχω ένα pair(priority, pid)
γιατί σε περίπτωση που μπούνε δύο διεργασίες με την ίδια προτεραιότητα βγαίνει πρώτη αυτή που μπήκε πρώτη ενώ αν είχα ένα pair θα έβγαινε
πρώτα αυτή με το μεγαλύτερο pid(έχει να κάνει και με τον operator σύκρισης στην δομή struct S).Η priority queue είναι δομή της STL.
Όσον αφορά το υπόλοιπο πρόγραμμα , για τους σημαφόρους δεν υλοποίησησα δομές ουρών προτεραιότητας . Απλά έχω έναν πίνακα με τις διεργασίες
(έναν πίνακα κλάσεων process) και αλλάζω τις καταστάσεις τους (από ready->cs ή blocked->ready or dead κοκ).Παρόλα αυτά έχω ένα πίνακα όπου
για κάθε ουρά αποθηκεύω χρήσιμες πληροφορίες (όπως το highest priority του σημαφόρου, το pid που χρησιμοποιεί το critical section και
το pid του επόμενου process που πρέπει να χρησιμοποιήσει το cs του σημαφόρου .Το normal priority χρησιμεύει για το priority inversion).
Μια διεργασία αφου δημιουργηθεί μπαίνει το priority queue και προσπαθεί να λάβει σημαφόρο.Σε περίπτωση που λάβει , βγαίνει από το 
priority queue.Αν αποτύχει να λάβει σημαφόρο (λόγω τις πιθανότητας k) ξαναμπαίνει στο priority queue και χάνει μια χρονοθυρίδα ζωής.
Σε περίπτωση που λάβει σημαφόρο μπορεί είτε να μπει στο critical section είτε αν υπάρχει άλλο process εκεί να μπλοκαριστεί.Το critical
section λειτουργεί με προεκχώρηση(preemption) ,δηλαδή αν είναι πολλά process σε critical section , εκτελείται το cs που έχει μέσα την
διεργασία με την υψηλότερη προτεραιότητα.Για το ξεμπλοκάρισμα διεργασιών, αρχικά ψάχνω το process με το μεγαλύτερο priority που είναι στο 
critical section.Έπειτα μειώνω το critical section time του και την ζωή του κατά μια χρονοθυρίδα κοιτάω αν έχει τελειώσει το cs του.
Αν δεν έχει τελειώσει δεν κάνω κάτι.Αν τελείωσε τότε πρώτα βλέπω τι πρέπει να γίνει με το process που τελείωσε το cs του.Αν δεν έχει άλλη ζωή
δεν ξαναμπαίνει στο priority queue με τις ready διεργασίες.Στην συνέχεια κοιτάω αν υπάρχει άλλο process που να περιμένει στην ουρά του.
Αν υπάρχει τότε το βάζω στο cs του και ανανεώνω το next_using_cs_pid που δείχνει πιο process πρέπει να μπει μετά στην ουρά. Το 
next_using_cs_pid  είναι πάντα η διεργασία με την επόμενη μεγαλύτερη προτεραιότητα στην ουρά.Αφού ολοκληρωθεί αυτή η δουλεία ανανεώνω τους
χρόνους αναμονής των διεργασιών που περιμένουν στην ουρά (αλλά και αυτών που προεκτοπίστηκαν από το cs τους) .Αν έχουν δημιουργηθεί και
πεθάνει όλες οι διεργασίες η προσομοιώση τελειώνει.Ενδεικτικά αποτελέσματα:

.
.
.
 Process blocked in semaphore
Process unblocked in semaphore
 Process blocked in semaphore
Process unblocked in semaphore
 Process blocked in semaphore
Process unblocked in semaphore
edww mesa
 priority 1 average waiting 293153493
 priority 2 average waiting 170465765
 priority 3 average waiting 59608331
 priority 4 average waiting 14333033
 priority 5 average waiting 13475991
 priority 6 average waiting 14433162
 priority 7 average waiting 10994512
 priority 8 average waiting 7660414

Βλέπουμε ότι οι διεργασίες με την μεγαλύτερη προτεραιότητα καταναλώνουν συνήθως λιγότερες χρονοθυρίδες από τις διεργασίες με χαμηλότερη 
προτεραιότητα.Έχει βέβαια σημασία και πότε δημιουργούνται οι διεργασίες.Αν πχ δημιουργούνται ενώ έίναι γεμάτες οι ουρές σημαφόρων
τότε αυτό μπορεί να οδηγήσει σε υψηλούς χρόνους αναμονής.Η εύρεση σε πόσες χρονοθυρίδες υπάρχει priority inversion και το πόσο μπλοκαρίζεται
μια διεργασία από διεργασία χαμηλότερης προτεραιότητας δεν έχει υλοποιηθεί. Ενδεχομένως να υπάρχει κάποιο bug με την μέτρηση του χρόνου
γιατί οι τιμές είναι υψηλές.

Ενδεικτικές εκτελέσεις:
make
./main 0.5 0.005 0.05 150 20 2
./main 0.5 0.005 0.05 150 20 2

make clean


Επισυνάπτω και μερικά δοκιμαστικά προγράμματα που με βοήθησαν με τις εκθετικές τιμές αλλά και μια παλιά έκδοση υλοποίησης της εργασίας μου
(σε περίπτωση που κάτι πήγε στραβά με αυτήν την υλοποίηση).
Φάκελος experiments
g++ main2.cpp semaphores.cpp
./a.out 0.05 0.05 0.05 108 20 5
rm a.out

Εκτέλεση δοκιματιστικών προγραμμάτων
g++ expdist.cpp
./a.out
rm a.out

Τέλος
